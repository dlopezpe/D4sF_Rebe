/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.37
 * @license MIT
 * @copyright (c) 2017-2021, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import _asyncToGenerator from '@babel/runtime-corejs3/helpers/esm/asyncToGenerator';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _regeneratorRuntime from '@babel/runtime-corejs3/regenerator';
import _mapInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/map';
import _sliceInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/slice';
import Feature from 'ol/Feature';
import VectorSource from 'ol/source/Vector';
import { getUid } from 'ol';
import Vue from 'vue';
import { vectorSource } from '../mixin';
import { createGeoJsonFmt, getFeatureId, initializeFeature, loadingAll, mergeFeatures, transform } from '../ol-ext';
import { constant, difference, isEqual, isFinite, isFunction, stubArray, isArray, isString, forEach, isPlainObject, pick } from '../util/minilo';
import { makeWatchers } from '../util/vue-helpers';
import { instanceOf } from '../util/assert';
import '@babel/runtime-corejs3/core-js-stable/instance/concat';
import _Object$assign from '@babel/runtime-corejs3/core-js-stable/object/assign';

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) { symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { Object.defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script = {
  name: 'vl-source-vector',
  mixins: [vectorSource],
  props: {
    /**
     * Array of GeoJSON features with coordinates in the map view projection.
     * @type {Object[]} features
     */
    features: {
      type: Array,
      default: stubArray
    },

    /**
     * Source loader factory.
     * Source loader should load features from some remote service, decode them and pas to `features` prop to render.
     * @type {(function(): FeatureLoader|undefined)} loaderFactory
     */
    loaderFactory: {
      type: Function
    },

    /**
     * Source format factory
     * @type {(function(): Feature|undefined)} formatFactory
     */
    formatFactory: {
      type: Function,
      default: defaultFormatFactory
    },

    /**
     * String or url factory
     * @type {(string|function(): string|FeatureUrlFunction|undefined)} url
     */
    url: [String, Function],

    /**
     * Loading strategy factory.
     * Extent here in map view projection.
     * @type {(function(): LoadingStrategy|undefined)} strategyFactory
     */
    strategyFactory: {
      type: Function,
      default: defaultStrategyFactory
    },
    overlaps: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    initializedFeatures: function initializedFeatures() {
      var _context;

      return _mapInstanceProperty(_context = this.features).call(_context, function (feature) {
        return initializeFeature(_objectSpread({}, feature));
      });
    },
    urlFunc: function urlFunc() {
      var _this = this;

      if (!this.url) return;
      var url = this.url;

      if (!isFunction(url)) {
        url = constant(this.url);
      }

      return function (extent, resolution, projection) {
        extent = transformExtent(extent, projection, _this.resolvedDataProjection);
        projection = _this.resolvedDataProjection;
        return url(extent, resolution, projection);
      };
    },
    loaderFunc: function loaderFunc() {
      var _this2 = this;

      if (!this.loaderFactory) return;
      var loader = this.loaderFactory();
      return /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(extent, resolution, projection) {
          var features;
          return _regeneratorRuntime.wrap(function _callee$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return loader(transformExtent(extent, projection, _this2.resolvedDataProjection), resolution, _this2.resolvedDataProjection);

                case 2:
                  features = _context2.sent;

                  if (isString(features) && features !== '') {
                    features = _this2.readSourceData(features);
                  }

                  if (isArray(features)) {
                    _this2.addFeatures(features);
                  }

                case 5:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      }();
    },
    loadingStrategy: function loadingStrategy() {
      return this.strategyFactory();
    },
    dataFormatIdent: function dataFormatIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'data_format');
    },
    dataFormat: function dataFormat() {
      return this.instanceFactoryCall(this.dataFormatIdent, this.formatFactory.bind(this));
    }
  },
  methods: {
    /**
     * @return {VectorSource}
     * @protected
     */
    createSource: function createSource() {
      return new VectorSource({
        attributions: this.attributions,
        features: this.$featuresCollection,
        projection: this.resolvedDataProjection,
        loader: this.loaderFunc,
        useSpatialIndex: this.useSpatialIndex,
        wrapX: this.wrapX,
        logo: this.logo,
        strategy: this.loadingStrategy,
        format: this.dataFormat,
        url: this.urlFunc,
        overlaps: this.overlaps
      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      vectorSource.methods.mount.call(this);
      this.addFeatures(this.features);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.clear();
      vectorSource.methods.unmount.call(this);
    },

    /**
     * @param {mixed} data
     * @returns {Array<FeatureLike>|Array<Feature>}
     */
    readSourceData: function readSourceData(data) {
      return this.dataFormat.readFeatures(data, {
        featureProjection: this.viewProjection,
        dataProjection: this.resolvedDataProjection
      });
    },
    addFeatures: function addFeatures(features) {
      var _this3 = this;

      var newFeatures = [];
      forEach(features || [], function (feature) {
        if (feature instanceof Vue) {
          feature = feature.$feature;
        } else if (isPlainObject(feature)) {
          feature = _this3.readFeatureInDataProj(feature);
        }

        instanceOf(feature, Feature);
        initializeFeature(feature);

        var foundFeature = _this3.getFeatureById(getFeatureId(feature));

        if (foundFeature) {
          mergeFeatures(foundFeature, feature);
        } else {
          newFeatures.push(feature);
        }
      });

      if (this.$source && features.length) {
        this.$source.addFeatures(newFeatures);
      } else {
        forEach(newFeatures, function (feature) {
          return vectorSource.methods.addFeature.call(_this3, feature);
        });
      }
    },
    removeFeatures: function removeFeatures(features) {
      var _this4 = this;

      if (!this.$source) {
        return vectorSource.methods.removeFeatures.call(this, features);
      }

      var changed = false;
      forEach(features, function (feature) {
        feature = _this4.getFeatureById(getFeatureId(feature));
        if (!feature) return;
        var featureKey = getUid(feature);

        if (featureKey in _this4.$source.nullGeometryFeatures_) {
          delete _this4.$source.nullGeometryFeatures_[featureKey];
        } else {
          if (_this4.$source.featuresRtree_) {
            _this4.$source.featuresRtree_.remove(feature);
          }
        }

        _this4.$source.removeFeatureInternal(feature);

        changed = true;
      });
      if (changed) this.$source.changed();
    }
  },
  watch: _objectSpread({
    initializedFeatures: {
      deep: true,
      handler: function handler(features) {
        if (!this.$source || isEqual(features, this.featuresDataProj)) return; // add new features

        this.addFeatures(features); // remove non-matched features

        this.removeFeatures(difference(this.getFeatures(), features, function (a, b) {
          return getFeatureId(a) === getFeatureId(b);
        }));
      }
    }
  }, makeWatchers(['loadingStrategy', 'dataFormat', 'urlFunc', 'loaderFactory', 'formatFactory', 'strategyFactory', 'overlaps'], function () {
    return function () {
      this.scheduleRecreate();
    };
  }))
};
/**
 * @return {LoadingStrategy}
 */

function defaultStrategyFactory() {
  return loadingAll;
}
/**
 * @return {GeoJSON}
 */


function defaultFormatFactory() {
  return createGeoJsonFmt();
}

function transformExtent(extent, sourceProj, destProj) {
  extent = _sliceInstanceProperty(extent).call(extent);

  if (isFinite(extent[0]) && isFinite(extent[1])) {
    var _transform = transform([extent[0], extent[1]], sourceProj, destProj);

    var _transform2 = _slicedToArray(_transform, 2);

    extent[0] = _transform2[0];
    extent[1] = _transform2[1];
  }

  if (isFinite(extent[2]) && isFinite(extent[3])) {
    var _transform3 = transform([extent[2], extent[3]], sourceProj, destProj);

    var _transform4 = _slicedToArray(_transform3, 2);

    extent[2] = _transform4[0];
    extent[3] = _transform4[1];
  }

  return extent;
}

var __vue_script__ = script;
/* template */

/* style */

var __vue_inject_styles__ = undefined;
/* scoped */

var __vue_scope_id__ = undefined;
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = undefined;
/* component normalizer */

function __vue_normalize__(template, style, script$$1, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
  var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {}; // For security concerns, we use only base name in production mode.

  component.__file = "source.vue";

  if (!component.render) {
    component.render = template.render;
    component.staticRenderFns = template.staticRenderFns;
    component._compiled = true;
    if (functional) component.functional = true;
  }

  component._scopeId = scope;

  return component;
}
/* style inject */

/* style inject SSR */


var Source = __vue_normalize__({}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, undefined, undefined);

function plugin(Vue$$1) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin.installed) {
    return;
  }

  plugin.installed = true;
  options = pick(options, 'dataProjection');

  _Object$assign(Source, options);

  Vue$$1.component(Source.name, Source);
}

export default plugin;
export { Source, plugin as install };
