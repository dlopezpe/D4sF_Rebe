{"version":3,"file":"index.js","sources":["src/component/map/map.vue?rollup-plugin-vue=script.js","src/component/map/map.vue","src/component/map/view.vue?rollup-plugin-vue=script.js","src/component/map/view.vue","src/component/map/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport Collection from 'ol/Collection'\nimport { defaults as createDefaultControls } from 'ol/control'\nimport { defaults as createDefaultInteractions } from 'ol/interaction'\nimport VectorLayer from 'ol/layer/Vector'\nimport Map from 'ol/Map'\nimport VectorSource from 'ol/source/Vector'\nimport View from 'ol/View'\nimport WebGLMap from 'ol/WebGLMap'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilChanged, map as mapObs } from 'rxjs/operators'\nimport Vue from 'vue'\nimport {\n  featuresContainer,\n  interactionsContainer,\n  layersContainer,\n  olCmp,\n  overlaysContainer,\n  projTransforms,\n} from '../../mixin'\nimport { getMapId, initializeInteraction, setMapDataProjection, setMapId } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasMap, hasView } from '../../util/assert'\nimport { isEqual, isPlainObject } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\n/**\n * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport\n * rendering and low level interaction events.\n */\nexport default {\n  name: 'vl-map',\n  mixins: [\n    olCmp,\n    layersContainer,\n    interactionsContainer,\n    overlaysContainer,\n    featuresContainer,\n    projTransforms,\n  ],\n  props: {\n    /**\n     * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object\n     * value is used to configure controls.\n     * @type {Object|boolean|Collection}\n     * @todo remove when vl-control-* components will be ready\n     */\n    defaultControls: {\n      type: [Object, Boolean, Collection],\n      default: true,\n    },\n    /**\n     * Options for default interactions added to the map by default. Object\n     * value is used to configure default interactions.\n     * @type {Object|boolean|Collection}\n     */\n    defaultInteractions: {\n      type: [Object, Boolean, Collection],\n      default: true,\n    },\n    /**\n     * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard\n     * interactions will always trigger. If this option is not specified, the element the library listens to keyboard\n     * events on is the component root element.\n     * @type {string|Element|Document}\n     */\n    keyboardEventTarget: [String, Element, Document],\n    /**\n     * When set to `true`, tiles will be loaded during animations.\n     * @type {boolean}\n     */\n    loadTilesWhileAnimating: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * When set to `true`, tiles will be loaded while interacting with the map.\n     * @type {boolean}\n     */\n    loadTilesWhileInteracting: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.\n     * Increasing this value can make it easier to click on the map.\n     * @type {Number}\n     */\n    moveTolerance: {\n      type: Number,\n      default: 1,\n    },\n    /**\n     * The ratio between physical pixels and device-independent pixels (dips) on the device.\n     * @type {number}\n     */\n    pixelRatio: {\n      type: Number,\n      default: () => window.devicePixelRatio || 1,\n    },\n    /**\n     * Maximum number tiles to load simultaneously.\n     * @type {number}\n     */\n    maxTilesLoading: {\n      type: Number,\n      default: 16,\n    },\n    /**\n     * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.\n     * @type {number|string}\n     */\n    tabindex: [String, Number],\n    /**\n     * Projection for input/output coordinates in plain data.\n     * @type {string}\n     */\n    dataProjection: String,\n    /**\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: true,\n    },\n    renderer: {\n      type: String,\n      default: 'canvas',\n      validator: val => ['canvas', 'webgl'].includes(val),\n    },\n  },\n  computed: {\n    controlsCollectionIdent () {\n      if (!this.olObjIdent) return\n\n      return this.makeIdent(this.olObjIdent, 'controls_collection')\n    },\n  },\n  methods: {\n    /**\n     * @return {module:ol/PluggableMap~PluggableMap}\n     * @protected\n     */\n    createOlObject () {\n      let Ctor\n      switch (this.renderer) {\n        case 'webgl':\n          Ctor = WebGLMap\n          break\n        case 'canvas':\n        default:\n          Ctor = Map\n      }\n\n      const map = new Ctor({\n        loadTilesWhileAnimating: this.loadTilesWhileAnimating,\n        loadTilesWhileInteracting: this.loadTilesWhileInteracting,\n        pixelRatio: this.pixelRatio,\n        moveTolerance: this.moveTolerance,\n        keyboardEventTarget: this.keyboardEventTarget,\n        maxTilesLoading: this.maxTilesLoading,\n        controls: this._controlsCollection,\n        interactions: this.$interactionsCollection,\n        layers: this.$layersCollection,\n        overlays: this.$overlaysCollection,\n        view: this.$view,\n      })\n\n      setMapId(map, this.id)\n      setMapDataProjection(map, this.dataProjection)\n      this._featuresOverlay.setMap(map)\n\n      return map\n    },\n    /**\n     * @param {number[]} pixel\n     * @return {number[]} Coordinates in the map data projection.\n     */\n    getCoordinateFromPixel (pixel) {\n      hasMap(this)\n\n      let coordinate = this.$map.getCoordinateFromPixel(pixel)\n\n      return this.pointToDataProj(coordinate)\n    },\n    /**\n     * @param {number[]} coordinate Coordinates in map data projection\n     * @return {number[]}\n     */\n    getPixelFromCoordinate (coordinate) {\n      hasMap(this)\n\n      return this.$map.getPixelFromCoordinate(this.pointToViewProj(coordinate))\n    },\n    /**\n     * Triggers focus on map container.\n     * @return {void}\n     */\n    focus () {\n      this.$el.focus()\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {function} callback\n     * @param {Object} [opts]\n     * @return {*|undefined}\n     */\n    forEachFeatureAtPixel (pixel, callback, opts = {}) {\n      hasMap(this)\n\n      return this.$map.forEachFeatureAtPixel(pixel, callback, opts)\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {function} callback\n     * @param {Object} [opts]\n     * @return {*|undefined}\n     */\n    forEachLayerAtPixel (pixel, callback, opts = {}) {\n      hasMap(this)\n\n      return this.$map.forEachLayerAtPixel(pixel, callback, opts)\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {Object} [opts]\n     */\n    getFeaturesAtPixel (pixel, opts = {}) {\n      hasMap(this)\n\n      return this.$map.getFeaturesAtPixel(pixel, opts)\n    },\n    /**\n     * Updates map size and re-renders map.\n     * @return {Promise}\n     */\n    refresh () {\n      this.updateSize()\n\n      return this.render().then(() => this::olCmp.methods.refresh())\n    },\n    /**\n     * @return {Promise}\n     */\n    render () {\n      return new Promise(resolve => {\n        hasMap(this)\n\n        this.$map.once('postrender', () => resolve())\n        this.$map.render()\n      })\n    },\n    /**\n     * Updates map size.\n     * @return {void}\n     */\n    updateSize () {\n      hasMap(this)\n\n      this.$map.updateSize()\n    },\n    /**\n     * @param {module:ol/View~View|Vue|undefined} view\n     * @return {void}\n     * @protected\n     */\n    setView (view) {\n      view = view instanceof Vue ? view.$view : view\n      view || (view = new View())\n\n      if (view !== this._view) {\n        this._view = view\n      }\n      if (this.$map && view !== this.$map.getView()) {\n        this.$map.setView(view)\n      }\n    },\n    /**\n     * @return {module:ol/View~View}\n     */\n    getView () {\n      return this._view\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      hasMap(this)\n\n      this.$map.setTarget(this.$el)\n      this.$nextTick(::this.updateSize)\n\n      this.subscribeAll()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      hasMap(this)\n\n      this.unsubscribeAll()\n      this.$map.setTarget(null)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToEvents()\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      const vm = this\n\n      return mergeDescriptors(\n        this::olCmp.methods.getServices(),\n        this::layersContainer.methods.getServices(),\n        this::interactionsContainer.methods.getServices(),\n        this::overlaysContainer.methods.getServices(),\n        this::featuresContainer.methods.getServices(),\n        {\n          get map () { return vm.$map },\n          get view () { return vm.$view },\n          get viewContainer () { return vm },\n        },\n      )\n    },\n  },\n  watch: {\n    ...makeWatchers([\n      'keyboardEventTarget',\n      'loadTilesWhileAnimating',\n      'loadTilesWhileInteracting',\n      'moveTolerance',\n      'pixelRatio',\n      'renderer',\n      'maxTilesLoading',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n    id (value) {\n      if (!this.$map || value === getMapId(this.$map)) {\n        return\n      }\n\n      setMapId(this.$map, value)\n    },\n    defaultControls: {\n      deep: true,\n      handler (value) {\n        this._controlsCollection.getArray().slice().forEach(control => {\n          if (control.get('vl_default')) {\n            this._controlsCollection.remove(control)\n          }\n        })\n        if (value === false) {\n          return\n        }\n        value = typeof value === 'object' ? value : undefined\n        this._controlsCollection.extend(createDefaultControls(value).getArray().map(control => {\n          control.set('vl_default', true)\n          return control\n        }))\n      },\n    },\n    defaultInteractions: {\n      deep: true,\n      handler (value) {\n        this._interactionsCollection.getArray().slice().forEach(interaction => {\n          if (interaction.get('vl_default')) {\n            this._interactionsCollection.remove(interaction)\n          }\n        })\n        if (value === false) {\n          return\n        }\n        value = typeof value === 'object' ? value : undefined\n        this._interactionsCollection.extend(createDefaultInteractions(value).getArray().map(interaction => {\n          interaction.set('vl_default', true)\n          return interaction\n        }))\n        console.log(this._interactionsCollection.getArray().slice())\n      },\n    },\n    wrapX (value) {\n      if (this._featuresOverlay == null) return\n\n      this._featuresOverlay.setSource(new VectorSource({\n        features: this.$featuresCollection,\n        wrapX: value,\n      }))\n    },\n    dataProjection (value) {\n      if (!this.$map) return\n\n      setMapDataProjection(this.$map, value)\n      this.scheduleRefresh()\n    },\n  },\n  created () {\n    this._view = new View({\n      center: [0, 0],\n      zoom: 0,\n    })\n    // todo make controls handling like with interactions\n    this._controlsCollection = this.instanceFactoryCall(this.controlsCollectionIdent, () => new Collection())\n    if (this.defaultControls instanceof Collection) {\n      this._controlsCollection = this.defaultControls\n    } else if (this.defaultControls !== false) {\n      this._controlsCollection = createDefaultControls(\n        isPlainObject(this.defaultControls)\n          ? this.defaultControls\n          : undefined,\n      )\n    }\n    this._controlsCollection.forEach(control => {\n      control.set('vl_default', true)\n    })\n    // todo initialize without interactions and provide vl-interaction-default component\n    if (this.defaultInteractions instanceof Collection) {\n      this._interactionsCollection = this.defaultInteractions\n    } else if (this.defaultInteractions !== false) {\n      this._interactionsCollection = createDefaultInteractions(\n        isPlainObject(this.defaultInteractions)\n          ? this.defaultInteractions\n          : undefined,\n      )\n    }\n    this._interactionsCollection.forEach(interaction => {\n      interaction = initializeInteraction(interaction)\n      interaction.set('vl_default', true)\n    })\n    // prepare default overlay\n    this._featuresOverlay = new VectorLayer({\n      source: new VectorSource({\n        features: this.$featuresCollection,\n        wrapX: this.wrapX,\n      }),\n    })\n\n    this::defineServices()\n  },\n}\n\nfunction defineServices () {\n  Object.defineProperties(this, {\n    /**\n     * OpenLayers map instance.\n     * @type {module:ol/PluggableMap~PluggableMap|undefined}\n     */\n    $map: {\n      enumerable: true,\n      get: () => this.$olObject,\n    },\n    /**\n     * OpenLayers view instance.\n     * @type {module:ol/View~View}\n     */\n    $view: {\n      enumerable: true,\n      get: this.getView,\n    },\n  })\n}\n\n/**\n * Subscribe to OL map events.\n *\n * @return {void}\n * @private\n */\nfunction subscribeToEvents () {\n  hasMap(this)\n  hasView(this)\n\n  // pointer\n  const pointerEvents = mergeObs(\n    observableFromOlEvent(this.$map, [\n      'click',\n      'dblclick',\n      'singleclick',\n    ]),\n    observableFromOlEvent(this.$map, [\n      'pointerdrag',\n      'pointermove',\n    ]).pipe(\n      distinctUntilChanged((a, b) => isEqual({\n        t: a.type,\n        c: a.coordinate,\n      }, {\n        t: b.type,\n        c: b.coordinate,\n      })),\n    ),\n  ).pipe(\n    mapObs(evt => ({\n      ...evt,\n      coordinate: this.pointToDataProj(evt.coordinate),\n    })),\n  )\n  // other\n  const otherEvents = observableFromOlEvent(this.$map, [\n    'movestart',\n    'moveend',\n    'postrender',\n    'rendercomplete',\n    'precompose',\n    'postcompose',\n    'rendercomplete',\n  ])\n\n  const events = mergeObs(pointerEvents, otherEvents)\n\n  this.subscribeTo(events, evt => {\n    this.$emit(evt.type, evt)\n  })\n}\n","<template>\n  <div :id=\"vmId\" :class=\"cmpName\" :tabindex=\"tabindex\">\n    <slot/>\n  </div>\n</template>\n\n<script>\n  import Collection from 'ol/Collection'\n  import { defaults as createDefaultControls } from 'ol/control'\n  import { defaults as createDefaultInteractions } from 'ol/interaction'\n  import VectorLayer from 'ol/layer/Vector'\n  import Map from 'ol/Map'\n  import VectorSource from 'ol/source/Vector'\n  import View from 'ol/View'\n  import WebGLMap from 'ol/WebGLMap'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilChanged, map as mapObs } from 'rxjs/operators'\n  import Vue from 'vue'\n  import {\n    featuresContainer,\n    interactionsContainer,\n    layersContainer,\n    olCmp,\n    overlaysContainer,\n    projTransforms,\n  } from '../../mixin'\n  import { getMapId, initializeInteraction, setMapDataProjection, setMapId } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasMap, hasView } from '../../util/assert'\n  import { isEqual, isPlainObject } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  /**\n   * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport\n   * rendering and low level interaction events.\n   */\n  export default {\n    name: 'vl-map',\n    mixins: [\n      olCmp,\n      layersContainer,\n      interactionsContainer,\n      overlaysContainer,\n      featuresContainer,\n      projTransforms,\n    ],\n    props: {\n      /**\n       * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object\n       * value is used to configure controls.\n       * @type {Object|boolean|Collection}\n       * @todo remove when vl-control-* components will be ready\n       */\n      defaultControls: {\n        type: [Object, Boolean, Collection],\n        default: true,\n      },\n      /**\n       * Options for default interactions added to the map by default. Object\n       * value is used to configure default interactions.\n       * @type {Object|boolean|Collection}\n       */\n      defaultInteractions: {\n        type: [Object, Boolean, Collection],\n        default: true,\n      },\n      /**\n       * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard\n       * interactions will always trigger. If this option is not specified, the element the library listens to keyboard\n       * events on is the component root element.\n       * @type {string|Element|Document}\n       */\n      keyboardEventTarget: [String, Element, Document],\n      /**\n       * When set to `true`, tiles will be loaded during animations.\n       * @type {boolean}\n       */\n      loadTilesWhileAnimating: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * When set to `true`, tiles will be loaded while interacting with the map.\n       * @type {boolean}\n       */\n      loadTilesWhileInteracting: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.\n       * Increasing this value can make it easier to click on the map.\n       * @type {Number}\n       */\n      moveTolerance: {\n        type: Number,\n        default: 1,\n      },\n      /**\n       * The ratio between physical pixels and device-independent pixels (dips) on the device.\n       * @type {number}\n       */\n      pixelRatio: {\n        type: Number,\n        default: () => window.devicePixelRatio || 1,\n      },\n      /**\n       * Maximum number tiles to load simultaneously.\n       * @type {number}\n       */\n      maxTilesLoading: {\n        type: Number,\n        default: 16,\n      },\n      /**\n       * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.\n       * @type {number|string}\n       */\n      tabindex: [String, Number],\n      /**\n       * Projection for input/output coordinates in plain data.\n       * @type {string}\n       */\n      dataProjection: String,\n      /**\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: true,\n      },\n      renderer: {\n        type: String,\n        default: 'canvas',\n        validator: val => ['canvas', 'webgl'].includes(val),\n      },\n    },\n    computed: {\n      controlsCollectionIdent () {\n        if (!this.olObjIdent) return\n\n        return this.makeIdent(this.olObjIdent, 'controls_collection')\n      },\n    },\n    methods: {\n      /**\n       * @return {module:ol/PluggableMap~PluggableMap}\n       * @protected\n       */\n      createOlObject () {\n        let Ctor\n        switch (this.renderer) {\n          case 'webgl':\n            Ctor = WebGLMap\n            break\n          case 'canvas':\n          default:\n            Ctor = Map\n        }\n\n        const map = new Ctor({\n          loadTilesWhileAnimating: this.loadTilesWhileAnimating,\n          loadTilesWhileInteracting: this.loadTilesWhileInteracting,\n          pixelRatio: this.pixelRatio,\n          moveTolerance: this.moveTolerance,\n          keyboardEventTarget: this.keyboardEventTarget,\n          maxTilesLoading: this.maxTilesLoading,\n          controls: this._controlsCollection,\n          interactions: this.$interactionsCollection,\n          layers: this.$layersCollection,\n          overlays: this.$overlaysCollection,\n          view: this.$view,\n        })\n\n        setMapId(map, this.id)\n        setMapDataProjection(map, this.dataProjection)\n        this._featuresOverlay.setMap(map)\n\n        return map\n      },\n      /**\n       * @param {number[]} pixel\n       * @return {number[]} Coordinates in the map data projection.\n       */\n      getCoordinateFromPixel (pixel) {\n        hasMap(this)\n\n        let coordinate = this.$map.getCoordinateFromPixel(pixel)\n\n        return this.pointToDataProj(coordinate)\n      },\n      /**\n       * @param {number[]} coordinate Coordinates in map data projection\n       * @return {number[]}\n       */\n      getPixelFromCoordinate (coordinate) {\n        hasMap(this)\n\n        return this.$map.getPixelFromCoordinate(this.pointToViewProj(coordinate))\n      },\n      /**\n       * Triggers focus on map container.\n       * @return {void}\n       */\n      focus () {\n        this.$el.focus()\n      },\n      /**\n       * @param {number[]} pixel\n       * @param {function} callback\n       * @param {Object} [opts]\n       * @return {*|undefined}\n       */\n      forEachFeatureAtPixel (pixel, callback, opts = {}) {\n        hasMap(this)\n\n        return this.$map.forEachFeatureAtPixel(pixel, callback, opts)\n      },\n      /**\n       * @param {number[]} pixel\n       * @param {function} callback\n       * @param {Object} [opts]\n       * @return {*|undefined}\n       */\n      forEachLayerAtPixel (pixel, callback, opts = {}) {\n        hasMap(this)\n\n        return this.$map.forEachLayerAtPixel(pixel, callback, opts)\n      },\n      /**\n       * @param {number[]} pixel\n       * @param {Object} [opts]\n       */\n      getFeaturesAtPixel (pixel, opts = {}) {\n        hasMap(this)\n\n        return this.$map.getFeaturesAtPixel(pixel, opts)\n      },\n      /**\n       * Updates map size and re-renders map.\n       * @return {Promise}\n       */\n      refresh () {\n        this.updateSize()\n\n        return this.render().then(() => this::olCmp.methods.refresh())\n      },\n      /**\n       * @return {Promise}\n       */\n      render () {\n        return new Promise(resolve => {\n          hasMap(this)\n\n          this.$map.once('postrender', () => resolve())\n          this.$map.render()\n        })\n      },\n      /**\n       * Updates map size.\n       * @return {void}\n       */\n      updateSize () {\n        hasMap(this)\n\n        this.$map.updateSize()\n      },\n      /**\n       * @param {module:ol/View~View|Vue|undefined} view\n       * @return {void}\n       * @protected\n       */\n      setView (view) {\n        view = view instanceof Vue ? view.$view : view\n        view || (view = new View())\n\n        if (view !== this._view) {\n          this._view = view\n        }\n        if (this.$map && view !== this.$map.getView()) {\n          this.$map.setView(view)\n        }\n      },\n      /**\n       * @return {module:ol/View~View}\n       */\n      getView () {\n        return this._view\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        hasMap(this)\n\n        this.$map.setTarget(this.$el)\n        this.$nextTick(::this.updateSize)\n\n        this.subscribeAll()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        hasMap(this)\n\n        this.unsubscribeAll()\n        this.$map.setTarget(null)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::subscribeToEvents()\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        const vm = this\n\n        return mergeDescriptors(\n          this::olCmp.methods.getServices(),\n          this::layersContainer.methods.getServices(),\n          this::interactionsContainer.methods.getServices(),\n          this::overlaysContainer.methods.getServices(),\n          this::featuresContainer.methods.getServices(),\n          {\n            get map () { return vm.$map },\n            get view () { return vm.$view },\n            get viewContainer () { return vm },\n          },\n        )\n      },\n    },\n    watch: {\n      ...makeWatchers([\n        'keyboardEventTarget',\n        'loadTilesWhileAnimating',\n        'loadTilesWhileInteracting',\n        'moveTolerance',\n        'pixelRatio',\n        'renderer',\n        'maxTilesLoading',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n      id (value) {\n        if (!this.$map || value === getMapId(this.$map)) {\n          return\n        }\n\n        setMapId(this.$map, value)\n      },\n      defaultControls: {\n        deep: true,\n        handler (value) {\n          this._controlsCollection.getArray().slice().forEach(control => {\n            if (control.get('vl_default')) {\n              this._controlsCollection.remove(control)\n            }\n          })\n          if (value === false) {\n            return\n          }\n          value = typeof value === 'object' ? value : undefined\n          this._controlsCollection.extend(createDefaultControls(value).getArray().map(control => {\n            control.set('vl_default', true)\n            return control\n          }))\n        },\n      },\n      defaultInteractions: {\n        deep: true,\n        handler (value) {\n          this._interactionsCollection.getArray().slice().forEach(interaction => {\n            if (interaction.get('vl_default')) {\n              this._interactionsCollection.remove(interaction)\n            }\n          })\n          if (value === false) {\n            return\n          }\n          value = typeof value === 'object' ? value : undefined\n          this._interactionsCollection.extend(createDefaultInteractions(value).getArray().map(interaction => {\n            interaction.set('vl_default', true)\n            return interaction\n          }))\n          console.log(this._interactionsCollection.getArray().slice())\n        },\n      },\n      wrapX (value) {\n        if (this._featuresOverlay == null) return\n\n        this._featuresOverlay.setSource(new VectorSource({\n          features: this.$featuresCollection,\n          wrapX: value,\n        }))\n      },\n      dataProjection (value) {\n        if (!this.$map) return\n\n        setMapDataProjection(this.$map, value)\n        this.scheduleRefresh()\n      },\n    },\n    created () {\n      this._view = new View({\n        center: [0, 0],\n        zoom: 0,\n      })\n      // todo make controls handling like with interactions\n      this._controlsCollection = this.instanceFactoryCall(this.controlsCollectionIdent, () => new Collection())\n      if (this.defaultControls instanceof Collection) {\n        this._controlsCollection = this.defaultControls\n      } else if (this.defaultControls !== false) {\n        this._controlsCollection = createDefaultControls(\n          isPlainObject(this.defaultControls)\n            ? this.defaultControls\n            : undefined,\n        )\n      }\n      this._controlsCollection.forEach(control => {\n        control.set('vl_default', true)\n      })\n      // todo initialize without interactions and provide vl-interaction-default component\n      if (this.defaultInteractions instanceof Collection) {\n        this._interactionsCollection = this.defaultInteractions\n      } else if (this.defaultInteractions !== false) {\n        this._interactionsCollection = createDefaultInteractions(\n          isPlainObject(this.defaultInteractions)\n            ? this.defaultInteractions\n            : undefined,\n        )\n      }\n      this._interactionsCollection.forEach(interaction => {\n        interaction = initializeInteraction(interaction)\n        interaction.set('vl_default', true)\n      })\n      // prepare default overlay\n      this._featuresOverlay = new VectorLayer({\n        source: new VectorSource({\n          features: this.$featuresCollection,\n          wrapX: this.wrapX,\n        }),\n      })\n\n      this::defineServices()\n    },\n  }\n\n  function defineServices () {\n    Object.defineProperties(this, {\n      /**\n       * OpenLayers map instance.\n       * @type {module:ol/PluggableMap~PluggableMap|undefined}\n       */\n      $map: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      /**\n       * OpenLayers view instance.\n       * @type {module:ol/View~View}\n       */\n      $view: {\n        enumerable: true,\n        get: this.getView,\n      },\n    })\n  }\n\n  /**\n   * Subscribe to OL map events.\n   *\n   * @return {void}\n   * @private\n   */\n  function subscribeToEvents () {\n    hasMap(this)\n    hasView(this)\n\n    // pointer\n    const pointerEvents = mergeObs(\n      observableFromOlEvent(this.$map, [\n        'click',\n        'dblclick',\n        'singleclick',\n      ]),\n      observableFromOlEvent(this.$map, [\n        'pointerdrag',\n        'pointermove',\n      ]).pipe(\n        distinctUntilChanged((a, b) => isEqual({\n          t: a.type,\n          c: a.coordinate,\n        }, {\n          t: b.type,\n          c: b.coordinate,\n        })),\n      ),\n    ).pipe(\n      mapObs(evt => ({\n        ...evt,\n        coordinate: this.pointToDataProj(evt.coordinate),\n      })),\n    )\n    // other\n    const otherEvents = observableFromOlEvent(this.$map, [\n      'movestart',\n      'moveend',\n      'postrender',\n      'rendercomplete',\n      'precompose',\n      'postcompose',\n      'rendercomplete',\n    ])\n\n    const events = mergeObs(pointerEvents, otherEvents)\n\n    this.subscribeTo(events, evt => {\n      this.$emit(evt.type, evt)\n    })\n  }\n</script>\n","//\n//\n//\n//\n//\n//\n\nimport View from 'ol/View'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilKeyChanged, map as mapObs } from 'rxjs/operators'\nimport Vue from 'vue'\nimport { olCmp, projTransforms } from '../../mixin'\nimport { EPSG_3857, MAX_ZOOM, MIN_ZOOM, ZOOM_FACTOR } from '../../ol-ext'\nimport { observableFromOlChangeEvent } from '../../rx-ext'\nimport { hasView } from '../../util/assert'\nimport { arrayLengthValidator, coalesce, isEqual, isFunction, isPlainObject, noop } from '../../util/minilo'\nimport { makeWatchers } from '../../util/vue-helpers'\n\n/**\n * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,\n * **resolution**, and **rotation** of the map.\n */\nexport default {\n  name: 'vl-view',\n  mixins: [olCmp, projTransforms],\n  props: {\n    /**\n     * The center coordinate in the view projection.\n     * @type {number[]}\n     * @default [0, 0]\n     */\n    center: {\n      type: Array,\n      default: () => [0, 0],\n      validator: arrayLengthValidator(2),\n    },\n    constrainRotation: {\n      type: [Boolean, Number],\n      default: true,\n    },\n    enableRotation: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * The extent that constrains the center defined in the view projection,\n     * in other words, center cannot be set outside this extent.\n     * @default undefined\n     */\n    extent: {\n      type: Array,\n      validator: arrayLengthValidator(4),\n    },\n    maxResolution: Number,\n    minResolution: Number,\n    /**\n     * @default 28\n     */\n    maxZoom: {\n      type: Number,\n      default: MAX_ZOOM,\n    },\n    /**\n     * @default 0\n     */\n    minZoom: {\n      type: Number,\n      default: MIN_ZOOM,\n    },\n    /**\n     * @type {string}\n     * @default EPSG:3857\n     */\n    projection: {\n      type: String,\n      default: EPSG_3857,\n    },\n    resolution: Number,\n    resolutions: Array,\n    /**\n     * The initial rotation for the view in **radians** (positive rotation clockwise).\n     * @type {number}\n     * @vueSync\n     */\n    rotation: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * Zoom level used to calculate the resolution for the view as `int` value. Only used if `resolution` is not defined.\n     * @type {number}\n     * @default 0\n     * @vueSync\n     */\n    zoom: {\n      type: Number,\n      default: MIN_ZOOM,\n    },\n    /**\n     * @default 2\n     */\n    zoomFactor: {\n      type: Number,\n      default: ZOOM_FACTOR,\n    },\n  },\n  computed: {\n    currentZoom () {\n      if (this.rev && this.$view) {\n        return this.$view.getZoom()\n      }\n\n      return this.zoom\n    },\n    currentRotation () {\n      if (this.rev && this.$view) {\n        return this.$view.getRotation()\n      }\n\n      return this.rotation\n    },\n    currentResolution () {\n      if (this.rev && this.$view) {\n        return this.$view.getResolution()\n      }\n\n      return this.resolution\n    },\n    currentCenter () {\n      if (this.rev && this.$view) {\n        return this.pointToDataProj(this.$view.getCenter())\n      }\n    },\n    currentCenterViewProj () {\n      if (this.rev && this.$view) {\n        return this.$view.getCenter()\n      }\n    },\n    /**\n     * @return {ProjectionLike}\n     */\n    resolvedDataProjection () {\n      // exclude this.projection from lookup to allow view rendering in projection\n      // that differs from data projection\n      return coalesce(\n        this.$viewContainer && this.$viewContainer.resolvedDataProjection,\n        this.$options.dataProjection,\n        this.viewProjection,\n      )\n    },\n  },\n  methods: {\n    /**\n     * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#animate}\n     * @param {...(AnimationOptions|function(boolean))} args\n     * @return {Promise} Resolves when animation completes\n     */\n    animate (...args) {\n      hasView(this)\n\n      let cb = noop\n      if (isFunction(args[args.length - 1])) {\n        cb = args[args.length - 1]\n        args = args.slice(0, args.length - 1)\n      }\n      args.forEach(opts => {\n        if (!Array.isArray(opts.center)) return\n        opts.center = this.pointToViewProj(opts.center)\n      })\n\n      return new Promise(\n        resolve => this.$view.animate(...args, complete => {\n          cb(complete)\n          resolve(complete)\n        }),\n      )\n    },\n    /**\n     * @return {ol/View~View}\n     * @protected\n     */\n    createOlObject () {\n      const view = new View({\n        center: this.pointToViewProj(this.center),\n        constrainRotation: this.constrainRotation,\n        enableRotation: this.enableRotation,\n        extent: this.extent ? this.extentToViewProj(this.extent) : undefined,\n        maxResolution: this.maxResolution,\n        minResolution: this.minResolution,\n        maxZoom: this.maxZoom,\n        minZoom: this.minZoom,\n        projection: this.projection,\n        resolution: this.resolution,\n        resolutions: this.resolutions,\n        rotation: this.rotation,\n        zoom: this.zoom,\n        zoomFactor: this.zoomFactor,\n      })\n\n      view.set('id', this.id)\n\n      return view\n    },\n    /**\n     * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#fit}\n     * @param {Object|module:ol/geom/SimpleGeometry~SimpleGeometry|module:ol/extent~Extent|Vue} geometryOrExtent\n     * @param {FitOptions} [options]\n     * @return {Promise} Resolves when view changes\n     */\n    fit (geometryOrExtent, options = {}) {\n      hasView(this)\n\n      // transform from GeoJSON, vl-feature to ol.Feature\n      if (isPlainObject(geometryOrExtent)) {\n        geometryOrExtent = this.readGeometryInDataProj(geometryOrExtent)\n      } else if (geometryOrExtent instanceof Vue) {\n        geometryOrExtent = geometryOrExtent.$geometry\n      }\n\n      let cb = options.callback || noop\n\n      return new Promise(resolve => {\n        this.$view.fit(geometryOrExtent, {\n          ...options,\n          callback: complete => {\n            cb(complete)\n            resolve(complete)\n          },\n        })\n      })\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this.$viewContainer && this.$viewContainer.setView(this)\n      this.subscribeAll()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unsubscribeAll()\n      this.$viewContainer && this.$viewContainer.setView(undefined)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToEvents()\n    },\n  },\n  watch: {\n    id (value) {\n      if (!this.$view || value === this.$view.get('id')) {\n        return\n      }\n\n      this.$view.set('id', value)\n    },\n    center (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      value = this.pointToViewProj(value)\n      if (!isEqual(value, this.currentCenterViewProj)) {\n        this.$view.setCenter(value)\n      }\n    },\n    resolution (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      if (value !== this.currentResolution) {\n        this.$view.setResolution(value)\n      }\n    },\n    zoom (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      if (value !== this.currentZoom) {\n        this.$view.setZoom(value)\n      }\n    },\n    rotation (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      if (value !== this.currentRotation) {\n        this.$view.setRotation(value)\n      }\n    },\n    minZoom (value) {\n      if (!this.$view) return\n\n      if (value !== this.$view.getMinZoom()) {\n        this.$view.setMinZoom(value)\n      }\n    },\n    maxZoom (value) {\n      if (!this.$view) return\n\n      if (value !== this.$view.getMaxZoom()) {\n        this.$view.setMaxZoom(value)\n      }\n    },\n    ...makeWatchers([\n      'resolvedDataProjection',\n      'constrainRotation',\n      'enableRotation',\n      'extent',\n      'maxResolution',\n      'minResolution',\n      'projection',\n      'resolutions',\n      'zoomFactor',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n  stubVNode: {\n    empty () {\n      return this.vmId\n    },\n  },\n  created () {\n    this::defineServices()\n  },\n}\n\nfunction defineServices () {\n  Object.defineProperties(this, {\n    /**\n     * @type {ol/View~View|undefined}\n     */\n    $view: {\n      enumerable: true,\n      get: () => this.$olObject,\n    },\n    $viewContainer: {\n      enumerable: true,\n      get: () => this.$services && this.$services.viewContainer,\n    },\n  })\n}\n\n/**\n * Subscribe to OpenLayers significant events\n * @return {void}\n * @private\n */\nfunction subscribeToEvents () {\n  hasView(this)\n\n  const ft = 1000 / 60\n  const resolution = observableFromOlChangeEvent(this.$view, 'resolution', true, ft)\n  const zoom = resolution.pipe(\n    mapObs(() => ({\n      prop: 'zoom',\n      value: this.$view.getZoom(),\n    })),\n    distinctUntilKeyChanged('value'),\n  )\n\n  const changes = mergeObs(\n    observableFromOlChangeEvent(this.$view, 'center', true, ft, () => this.pointToDataProj(this.$view.getCenter())),\n    observableFromOlChangeEvent(this.$view, 'rotation', true, ft),\n    resolution,\n    zoom,\n  )\n\n  this.subscribeTo(changes, ({ prop, value }) => {\n    ++this.rev\n\n    this.$nextTick(() => {\n      this.$emit(`update:${prop}`, value)\n    })\n  })\n}\n","<template>\n  <i :id=\"vmId\" :class=\"cmpName\" style=\"display: none !important;\">\n    <slot :center=\"currentCenter\" :zoom=\"currentZoom\" :resolution=\"currentResolution\" :rotation=\"currentRotation\"/>\n  </i>\n</template>\n\n<script>\n  import View from 'ol/View'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilKeyChanged, map as mapObs } from 'rxjs/operators'\n  import Vue from 'vue'\n  import { olCmp, projTransforms } from '../../mixin'\n  import { EPSG_3857, MAX_ZOOM, MIN_ZOOM, ZOOM_FACTOR } from '../../ol-ext'\n  import { observableFromOlChangeEvent } from '../../rx-ext'\n  import { hasView } from '../../util/assert'\n  import { arrayLengthValidator, coalesce, isEqual, isFunction, isPlainObject, noop } from '../../util/minilo'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  /**\n   * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,\n   * **resolution**, and **rotation** of the map.\n   */\n  export default {\n    name: 'vl-view',\n    mixins: [olCmp, projTransforms],\n    props: {\n      /**\n       * The center coordinate in the view projection.\n       * @type {number[]}\n       * @default [0, 0]\n       */\n      center: {\n        type: Array,\n        default: () => [0, 0],\n        validator: arrayLengthValidator(2),\n      },\n      constrainRotation: {\n        type: [Boolean, Number],\n        default: true,\n      },\n      enableRotation: {\n        type: Boolean,\n        default: true,\n      },\n      /**\n       * The extent that constrains the center defined in the view projection,\n       * in other words, center cannot be set outside this extent.\n       * @default undefined\n       */\n      extent: {\n        type: Array,\n        validator: arrayLengthValidator(4),\n      },\n      maxResolution: Number,\n      minResolution: Number,\n      /**\n       * @default 28\n       */\n      maxZoom: {\n        type: Number,\n        default: MAX_ZOOM,\n      },\n      /**\n       * @default 0\n       */\n      minZoom: {\n        type: Number,\n        default: MIN_ZOOM,\n      },\n      /**\n       * @type {string}\n       * @default EPSG:3857\n       */\n      projection: {\n        type: String,\n        default: EPSG_3857,\n      },\n      resolution: Number,\n      resolutions: Array,\n      /**\n       * The initial rotation for the view in **radians** (positive rotation clockwise).\n       * @type {number}\n       * @vueSync\n       */\n      rotation: {\n        type: Number,\n        default: 0,\n      },\n      /**\n       * Zoom level used to calculate the resolution for the view as `int` value. Only used if `resolution` is not defined.\n       * @type {number}\n       * @default 0\n       * @vueSync\n       */\n      zoom: {\n        type: Number,\n        default: MIN_ZOOM,\n      },\n      /**\n       * @default 2\n       */\n      zoomFactor: {\n        type: Number,\n        default: ZOOM_FACTOR,\n      },\n    },\n    computed: {\n      currentZoom () {\n        if (this.rev && this.$view) {\n          return this.$view.getZoom()\n        }\n\n        return this.zoom\n      },\n      currentRotation () {\n        if (this.rev && this.$view) {\n          return this.$view.getRotation()\n        }\n\n        return this.rotation\n      },\n      currentResolution () {\n        if (this.rev && this.$view) {\n          return this.$view.getResolution()\n        }\n\n        return this.resolution\n      },\n      currentCenter () {\n        if (this.rev && this.$view) {\n          return this.pointToDataProj(this.$view.getCenter())\n        }\n      },\n      currentCenterViewProj () {\n        if (this.rev && this.$view) {\n          return this.$view.getCenter()\n        }\n      },\n      /**\n       * @return {ProjectionLike}\n       */\n      resolvedDataProjection () {\n        // exclude this.projection from lookup to allow view rendering in projection\n        // that differs from data projection\n        return coalesce(\n          this.$viewContainer && this.$viewContainer.resolvedDataProjection,\n          this.$options.dataProjection,\n          this.viewProjection,\n        )\n      },\n    },\n    methods: {\n      /**\n       * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#animate}\n       * @param {...(AnimationOptions|function(boolean))} args\n       * @return {Promise} Resolves when animation completes\n       */\n      animate (...args) {\n        hasView(this)\n\n        let cb = noop\n        if (isFunction(args[args.length - 1])) {\n          cb = args[args.length - 1]\n          args = args.slice(0, args.length - 1)\n        }\n        args.forEach(opts => {\n          if (!Array.isArray(opts.center)) return\n          opts.center = this.pointToViewProj(opts.center)\n        })\n\n        return new Promise(\n          resolve => this.$view.animate(...args, complete => {\n            cb(complete)\n            resolve(complete)\n          }),\n        )\n      },\n      /**\n       * @return {ol/View~View}\n       * @protected\n       */\n      createOlObject () {\n        const view = new View({\n          center: this.pointToViewProj(this.center),\n          constrainRotation: this.constrainRotation,\n          enableRotation: this.enableRotation,\n          extent: this.extent ? this.extentToViewProj(this.extent) : undefined,\n          maxResolution: this.maxResolution,\n          minResolution: this.minResolution,\n          maxZoom: this.maxZoom,\n          minZoom: this.minZoom,\n          projection: this.projection,\n          resolution: this.resolution,\n          resolutions: this.resolutions,\n          rotation: this.rotation,\n          zoom: this.zoom,\n          zoomFactor: this.zoomFactor,\n        })\n\n        view.set('id', this.id)\n\n        return view\n      },\n      /**\n       * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#fit}\n       * @param {Object|module:ol/geom/SimpleGeometry~SimpleGeometry|module:ol/extent~Extent|Vue} geometryOrExtent\n       * @param {FitOptions} [options]\n       * @return {Promise} Resolves when view changes\n       */\n      fit (geometryOrExtent, options = {}) {\n        hasView(this)\n\n        // transform from GeoJSON, vl-feature to ol.Feature\n        if (isPlainObject(geometryOrExtent)) {\n          geometryOrExtent = this.readGeometryInDataProj(geometryOrExtent)\n        } else if (geometryOrExtent instanceof Vue) {\n          geometryOrExtent = geometryOrExtent.$geometry\n        }\n\n        let cb = options.callback || noop\n\n        return new Promise(resolve => {\n          this.$view.fit(geometryOrExtent, {\n            ...options,\n            callback: complete => {\n              cb(complete)\n              resolve(complete)\n            },\n          })\n        })\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this.$viewContainer && this.$viewContainer.setView(this)\n        this.subscribeAll()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.unsubscribeAll()\n        this.$viewContainer && this.$viewContainer.setView(undefined)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::subscribeToEvents()\n      },\n    },\n    watch: {\n      id (value) {\n        if (!this.$view || value === this.$view.get('id')) {\n          return\n        }\n\n        this.$view.set('id', value)\n      },\n      center (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        value = this.pointToViewProj(value)\n        if (!isEqual(value, this.currentCenterViewProj)) {\n          this.$view.setCenter(value)\n        }\n      },\n      resolution (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        if (value !== this.currentResolution) {\n          this.$view.setResolution(value)\n        }\n      },\n      zoom (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        if (value !== this.currentZoom) {\n          this.$view.setZoom(value)\n        }\n      },\n      rotation (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        if (value !== this.currentRotation) {\n          this.$view.setRotation(value)\n        }\n      },\n      minZoom (value) {\n        if (!this.$view) return\n\n        if (value !== this.$view.getMinZoom()) {\n          this.$view.setMinZoom(value)\n        }\n      },\n      maxZoom (value) {\n        if (!this.$view) return\n\n        if (value !== this.$view.getMaxZoom()) {\n          this.$view.setMaxZoom(value)\n        }\n      },\n      ...makeWatchers([\n        'resolvedDataProjection',\n        'constrainRotation',\n        'enableRotation',\n        'extent',\n        'maxResolution',\n        'minResolution',\n        'projection',\n        'resolutions',\n        'zoomFactor',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n    stubVNode: {\n      empty () {\n        return this.vmId\n      },\n    },\n    created () {\n      this::defineServices()\n    },\n  }\n\n  function defineServices () {\n    Object.defineProperties(this, {\n      /**\n       * @type {ol/View~View|undefined}\n       */\n      $view: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      $viewContainer: {\n        enumerable: true,\n        get: () => this.$services && this.$services.viewContainer,\n      },\n    })\n  }\n\n  /**\n   * Subscribe to OpenLayers significant events\n   * @return {void}\n   * @private\n   */\n  function subscribeToEvents () {\n    hasView(this)\n\n    const ft = 1000 / 60\n    const resolution = observableFromOlChangeEvent(this.$view, 'resolution', true, ft)\n    const zoom = resolution.pipe(\n      mapObs(() => ({\n        prop: 'zoom',\n        value: this.$view.getZoom(),\n      })),\n      distinctUntilKeyChanged('value'),\n    )\n\n    const changes = mergeObs(\n      observableFromOlChangeEvent(this.$view, 'center', true, ft, () => this.pointToDataProj(this.$view.getCenter())),\n      observableFromOlChangeEvent(this.$view, 'rotation', true, ft),\n      resolution,\n      zoom,\n    )\n\n    this.subscribeTo(changes, ({ prop, value }) => {\n      ++this.rev\n\n      this.$nextTick(() => {\n        this.$emit(`update:${prop}`, value)\n      })\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Map from './map.vue'\nimport View from './view.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Map, options)\n  Object.assign(View, options)\n\n  Vue.component(Map.name, Map)\n  Vue.component(View.name, View)\n}\n\nexport default plugin\n\nexport {\n  Map,\n  View,\n  plugin as install,\n}\n"],"names":["name","mixins","olCmp","layersContainer","interactionsContainer","overlaysContainer","featuresContainer","projTransforms","props","defaultControls","type","Object","Boolean","Collection","default","defaultInteractions","keyboardEventTarget","String","Element","Document","loadTilesWhileAnimating","loadTilesWhileInteracting","moveTolerance","Number","pixelRatio","window","devicePixelRatio","maxTilesLoading","tabindex","dataProjection","wrapX","renderer","validator","val","computed","controlsCollectionIdent","olObjIdent","makeIdent","methods","createOlObject","Ctor","WebGLMap","Map","map","controls","_controlsCollection","interactions","$interactionsCollection","layers","$layersCollection","overlays","$overlaysCollection","view","$view","setMapId","id","setMapDataProjection","_featuresOverlay","setMap","getCoordinateFromPixel","pixel","hasMap","coordinate","$map","pointToDataProj","getPixelFromCoordinate","pointToViewProj","focus","$el","forEachFeatureAtPixel","callback","opts","forEachLayerAtPixel","getFeaturesAtPixel","refresh","updateSize","render","then","resolve","once","setView","Vue","View","_view","getView","mount","setTarget","$nextTick","subscribeAll","unmount","unsubscribeAll","subscribeToEvents","getServices","vm","mergeDescriptors","viewContainer","watch","makeWatchers","scheduleRecreate","value","getMapId","deep","handler","getArray","forEach","control","get","remove","undefined","extend","createDefaultControls","set","_interactionsCollection","interaction","createDefaultInteractions","console","log","setSource","VectorSource","features","$featuresCollection","scheduleRefresh","created","center","zoom","instanceFactoryCall","isPlainObject","initializeInteraction","VectorLayer","source","defineServices","defineProperties","enumerable","$olObject","hasView","pointerEvents","mergeObs","observableFromOlEvent","pipe","distinctUntilChanged","a","b","isEqual","t","c","mapObs","evt","otherEvents","events","subscribeTo","$emit","Array","arrayLengthValidator","constrainRotation","enableRotation","extent","maxResolution","minResolution","maxZoom","MAX_ZOOM","minZoom","MIN_ZOOM","projection","EPSG_3857","resolution","resolutions","rotation","zoomFactor","ZOOM_FACTOR","currentZoom","rev","getZoom","currentRotation","getRotation","currentResolution","getResolution","currentCenter","getCenter","currentCenterViewProj","resolvedDataProjection","coalesce","$viewContainer","$options","viewProjection","animate","args","cb","noop","isFunction","length","isArray","complete","extentToViewProj","fit","geometryOrExtent","options","readGeometryInDataProj","$geometry","getAnimating","setCenter","setResolution","setZoom","setRotation","getMinZoom","setMinZoom","getMaxZoom","setMaxZoom","stubVNode","empty","vmId","$services","ft","observableFromOlChangeEvent","prop","distinctUntilKeyChanged","changes","plugin","installed","pick","component"],"mappings":"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"}